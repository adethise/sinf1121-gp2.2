\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{lmodern}
\usepackage{listings}
\usepackage{color}
\usepackage{tikz}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=Java,                   % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=4,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}


\date{Vendredi 10 octobre 2014}
\author{Groupe 2.2}
\title{Produit Mission 2 }

\begin{document}
\maketitle


\section*{Question 1 - Henneton Romain}

	La profondeur (\textit{depth}) d'un noeud p est égal au nombre de parents de p. La profondeur de la racine d'un arbre est donc égale à 0.
	
L'ensemble des noeuds ayant une profondeur égale sont appelés noeuds d'un même niveau (\textit{level}). Et la valeur de ce niveau est égal à la profondeur commune des noeuds qui le composent.

	La hauteur(\textit{height}) d'un arbre (sous-arbre) est égale à la profondeur maximum de cet arbre (sous-arbre).
	
	Ces notions sont valables pour tout type d'arbre et pas uniquement pour les arbres binaires. Elles ne dépendent pas non plus de la structure de données utilisée pour représenter l'arbre, car ces caractéristiques sont propres à l'arbre (la façon dont on représente l'arbre "sur papier" ne dépend pas de l'implémentation informatique qui va suivre) et ne dépendent pas de son implémentation.
	
\section*{Question 2 - Henneton Romain}
	Un arbre binaire est un arbre ordonné ayant les trois propriétés suivantes :
	
\begin{itemize}
\item Chaque noeud a maximum deux enfants.
\item Chaque enfant est soit un enfant de droite (\textit{left child}), soit un enfant de gauche (\textit{right child}).
\item Un enfant de gauche précède un enfant de droite pour un parent donné. (=côté ordonné de l'arbre binaire)
\end{itemize}

Un arbre est ordonné si il y a un ordre entre les enfants de chaque noeud. C'est ordre est en général visualisé en arrangeant "frères" de gauche à droite selon leur ordre. Un arbre impropre n'est pas nécessairement désordonné. (exemple ci-dessous)
\begin{figure}[!h]
\center
\includegraphics[scale=0.5]{q2impropre.png}
\end{figure}

Pour un arbre de taille connue et fixée, il peut être intéressant d'utiliser une implémentation basée sur un tableau. En effet, le nombre maximal d'éléments d'un arbre binaire de N éléments est $2^N-1$, et la taille peut donc être fixée avant l'insertion des données dans l'arbre.

Avantages :
\begin{itemize}
\item Il est aisé de trouver le niveau d'un élément (log(p)), de trouver l'index du parent ( (p-1)/2), de trouver l'index des enfants d'un noeud ( p*2+1 et p*2+2 ).
\item Dans certain cas précis, l'utilisation d'un tableau pour implémenter un arbre binaire est efficace en terme d'utilisation de mémoire (pour les "heaps" par exemple).
\end{itemize}
Inconvénients :
\begin{itemize}
\item L'espace utilisé est exponentiel pour le pire des cas 
\item Les opérations sur arbre sont peu efficace. Par exemple en cas de suppression d'un noeud nécessite de redéplacer l'ensemble de la descendance du noeud supprimé.
\end{itemize}

\section*{Question 3 - Arnaud Dethise}

	Un arbre équilibré (\textit{balanced}) est un arbre binaire dont la hauteur est minimisée. Ainsi, un arbre binaire contenant $l$ feuilles (\textit{leafs}) est équilibré s'il s'étend sur $log_{2}(l)+1$ niveaux, arrondi vers le haut.
	Un arbre binaire équilibré contenant $n$ nœuds s'étend sur $log_{2}(n+1)$ niveaux.
	
	Remarque : un arbre correspondant à cette définition est dit \textit{à critère d'équilibre partiel}. Un arbre \textit{à critère d'équilibre total} devrait aussi être complet (voir ci-après), mais est rarement utilisé car cette contrainte peut imposer une réorganisation de l'arbre entier en cas d'insertion.
	
	Un arbre propre est un arbre dans lequel tout nœud possède 0 ou 2 sous-arbres.
	Un arbre binaire équilibré n'est pas forcément propre, comme on peut le voir dans l'arbre représenté sur la figure \ref{balanced_improper_tree}.
	
	\begin{figure}[!h]
	\begin{center}
		\includegraphics[scale=.7]{q3-balanced_improper_tree.png}
		\caption{Les nœuds 23 et 54 n'ont qu'un seul \textit{subtree}, l'arbre est donc impropre. Il est par contre équilibré (11 nœuds, 4 niveaux). \textit{(source csupomona.edu)}}
		\label{balanced_improper_tree}
	\end{center}
	\end{figure}
	
	Un arbre binaire essentiellement complet est un arbre pour lequel chaque niveau à l'exception du dernier est totalement rempli, et tous les nœuds du dernier niveau sont placés aussi loin que possible à gauche.
	Le fait de définir l'arbre comme \textit{essentiellement} complet signifie que le dernier niveau peut ne pas être totalement rempli.
	
	Un arbre complet est toujours équilibré car le fait de placer les nouveaux nœuds sur le niveau le plus haut possible minimise effectivement la hauteur de l'arbre.
	Un arbre équilibré n'est en revanche pas forcément complet. Un contre-exemple est donné à la figure \ref{balanced_incomplete_tree}.
	
	\begin{figure}[!h]
	\begin{center}
		\includegraphics[scale=.7]{q3-balanced_incomplete_tree.png}
		\caption{L'arbre compte 11 nœuds et 4 niveaux, il est donc équilibré. En revanche, le niveau $n-1$ n'est pas rempli et tous les nœuds du niveau $n$ ne sont pas à gauche, l'arbre est donc incomplet. \textit{(source boyet.com, edited)}}
		\label{balanced_incomplete_tree}
	\end{center}
	\end{figure}
	
	Attention à ne pas confondre les arbres équilibrés et les arbres AVL, quasi équilibrés.


\section*{Question 4 - Lemaire Jérôme}

La représentation d'un arbre par une structure chaînée est tel qu'un noeud à une position p maintient des références vers un élément à mémoriser et vers les noeuds associés aux enfants et au parent de p si il existe sinon la référence est \textit{null}. Une liste chaînée est un cas particulier d'un structure chaînée car pour avoir une liste chaînée, l'hypothèse de la linéarité de la séquence de la collection de noeuds a du être émise. Un structure chaînée est qu'en a elle une collection de noeuds relié entre eux de manière quelconque.//
Ils permettent tous les deux de stocker des éléments à des positions définies. Dans une chacun des modèles, les noeuds sont référencés entre eux. //
Dans le DSAJ-6, la classe qui implémente un arbre binaire par une structure chaînée est la classe LinkedBinaryTree situé aux pages 297-299.//
Il est possible d'implémenter un arbre sous forme de liste chaînée mais cela implique beaucoup de travail et rend la compréhension de l'implémentation plus difficile. Voici comment procéder pour l'implémentation d'un arbre binaire en liste chaînée. Premièrement, il faut définir une fonction f tel que : //
\begin{itemize}
	\item si p est la racine alors f(p)=0
	\item si p est l'enfant de droite de la position q alors f(p)=2*f(q)+1
	\item si p est l'enfant de gauche de la position q alors f(p)=2*f(q)+2
\end{itemize}
Où f(p) représente la nouvelle position de p dans la liste chaînée. Ensuite, on crée une liste chaînée contenant un nombre d'élément égale à la valeur maximale du f(p) et on rempli le position calculée (f(p)) avec les éléments de la position p, en laissant de position vide de tout élément. Si on veut travailler sur un arbre général, il faudra définir une autre fonction f.




\section*{Question 5 - Arnaud Dethise}

	Considérons une variation de la classe LinkedBinaryTree de DSAJ ne contenant pas de méthode \textit{parent} et n'implémentant que l'interface \textit{Iterable<E>}, qui ne permet pas de parcourir l'iterator vers l'arrière.
	Cela signifie qu'il est impossible de remonter dans l'arbre, et que par conséquent chaque accès à un nœud n'appartenant pas à un sous-arbre doit se faire depuis la racine.
	Si nous voulons pouvoir nous déplacer dans l'arbre, il faut donc créer la méthode \textit{parent}, ci-après.
	
	\begin{lstlisting}
public Position<E> parent(Position<E> p) throws IllegalArgumentException
{
	Node<E> node = validate(p);
	return getParentDfs(node, root);
}

private Position<E> getParentDfs(Node<E> node, Node<E> hook)
{
	if (hook == null) return null;
	else
	{
		if (node == hook.getLeft() || node == hook.getRight()) return hook;
		else
		{
			Node<E> tmp;
			tmp = getParentDfs(node, hook.getLeft());
			return (tmp != null ? tmp : getParentDfs(node,hook.getRight()));
		}
	}
}
	\end{lstlisting}
	
	Cet algorithme parcourt dans le pire cas une fois chaque nœud de l'arbre, et a donc une complexité temporelle O(n), n étant le nombre de nœuds dans l'arbre.

\section*{Question 6 - Gil De Grove}
\lstinputlisting{LinkedRBinaryTree.java}
<<<<<<< Updated upstream
\section*{Question 7}
\section*{Question 8 - Lemaire Jérôme}
Il faut utiliser l'approche de \textit{Euler TourBinary traversal} sur un arbre binaire.Cette approche peut être vue comme une promenade autour des contours de l'arbre. C'est une approche récursive car nous pouvons décomposer notre parcours en sous parcours pour chacun des sous arbres. Je n'ai malheureusement pas réussi à implémenter correctement dans les temps le pseudo code de la méthode toString(). Mais voici, l'algorithme que je vais utiliser pour l'implémenter d'ici lundi.

\begin{itemize}
	\item si la position p est interne, on print "`("`
	\item si la position p a un enfant à gauche lc, alors on fait un appel récursif sur la nouvelle position lc et le sous-arbre de gauche. //Ensuite on print la valeur ou l'opérateur se trouvant à la position p.
	\item si la position p a un enfant à droite rc, alors on fait un appel récursif sur la nouvelle position rc et le sous-arbre de droite.//Ensuite on print la valeur ou l'opérateur se trouvant à la position p.
	\item si la position p est interne, on print "`)"`
\end{itemize}


=======
\section*{Question 7 - Aurian de Potter}

Une expression arithmétique peut être représentée par un arbre binaire dont les noeuds externes sont associés à des variables ou des constantes, et dont les nœuds internes sont associés à l'un des opérateurs +, -, x, et /.\\

L'avantage est que cette représentation est un arbre binaire propre, étant donné que chaque opérateur +, -, x, et / prend exactement deux opérandes. Bien sûr, si nous devions permettre aux opérateurs unaires, comme la négation (-), comme dans "-x," alors nous pourrions avoir un arbre binaire impropre.\\

Voiçi deux expemples de représentation :\\

\textbf{1 + (2 * 3) :} \includegraphics[scale=1]{arithmetique.png}
\textbf{sin x + (x / 3) :} \includegraphics[scale=0.5]{analytique.png}\\

Nous pouvons remarquer une caractéristique supplémentaire pour la représentation d'une expression analytique, en effet dans ce cas la fonction sinus n'a qu'un seul enfant.

\section*{Question 8}
>>>>>>> Stashed changes
\clearpage
\section*{Question 9 - Zacharie Kerger}

Chaque arbre représente la dérivée formelle de l'expression présente à sa gauche.\\

\textbf{(f + g)' =} \includegraphics[scale=1]{q9-f+g.png}
\textbf{(f - g)' =} \includegraphics[scale=1]{q9-f-g.png}
\textbf{(f * g)' =} \includegraphics[scale=1]{q9-fg.png} \\
\textbf{($\frac{f}{g}$)' =} \includegraphics[scale=1]{q9-fdivg.png}
\textbf{sin(f)' =} \includegraphics[scale=1]{q9-sinf.png} \\
\textbf{cos(f)' =} \includegraphics[scale=1]{q9-cosf.png}
\textbf{($f^{a}$)' =} \includegraphics[scale=1]{q9-fa.png}\\
\textbf{($\frac{1}{g}$)' =} \includegraphics[scale=1]{q9-1divg.png} 

Pour chaque cas de dérivation, il est nécessaire de créer une fonction différente qui permettra d'adapter l'arbre de base (généralement composé d'une racine et de 2 feuilles) vers un arbre représentant la dérivée.\\

\underline{Exemple}:\\

Prenons le cas du produit, l'arbre de base est constitué d'une racine "*" et de 2 feuilles "f" et "g". Pour obtenir l'arbre présenté ci-dessus, il faudra appliquer une fonction se présentant comme suit:

\begin{lstlisting}
produit(Tree T){
    Modifier la racine "*" par "+" // via la methode set
	Stocker les feuilles de gauche (f) et de droite (g)
	Modifier les feuilles de gauche et de droite par "*" // methode set
	addLeft(sous-arbre gauche, derive(f)) // derive(f) represente la derivee de f
	addRight(sous-arbre gauche, g)
	addLeft(sous-arbre droit, f)
	addRight(sous-arbre droite, derive(g))// derive(g) represente la derivee de g
	Return T 
}
\end{lstlisting}
\end{document}
