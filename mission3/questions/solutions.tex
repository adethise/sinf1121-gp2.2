\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{lmodern}
\usepackage{listings}
\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=Java,                 % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}


\date{24 octobre 2014}
\author{Groupe 2.2}
\title{Produit Mission 3}

\begin{document}
\maketitle

\section*{Question 1 : Arnaud Dethise}

	Les \texttt{Maps} sont des tableaux associatifs. Il s'agit d'un ensemble d'\textit{entries} qui sont des paires clé/valeur. Chaque entry associe une clé unique à sa valeur.

	Les méthodes principales sont \texttt{put(k,v)} qui ajoute à la map la valeur \textit{v} associé à la clé \textit{k} ; \texttt{get(k)} qui retourne la valeur associée à la clé \textit{k} ; et \texttt{remove(k)} qui retire l'entry donc la clé est \textit{k}.
	
	\vspace{0.35cm}

	Bien qu'il soit normalement possible de mettre un \texttt{null} comme valeur d'une entrée, certaines implémentations de Map en Java l'interdisent explicitement pour éviter les ambiguïtés dans le cas où une clé n'existe pas. En effet, si la clé \textit{k} n'existe pas, \texttt{get(k)} renverra \texttt{null}. Si une entrée (k,\texttt{null}) existe, \texttt{get(k)} renverra \texttt{null} non parce que la clé n'existe pas, mais parce que \texttt{null} est la valeur associée à \textit{k}.
	
	\vspace{0.35cm}
	
	Exemples d'applications importantes :
	\begin{itemize}
		\item Liste de membre de personnel. Par exemple, l'UCL avec une map, une entry par étudiant, le NOMA comme clé et le nom comme valeur.	
		\item Un DNS mappe une url avec l'ip qui lui est associée.
		\item Un programme de graphisme peut associer un alias (\texttt{bleu}) avec une couleur (\texttt{rgb(0,0,255)}).
	\end{itemize}

\section*{Question 2 : Arnaud Dethise}

	\subsection*{Hash table}
	
	Au lieu d'utiliser directement les objets comme clé, on calcule leur hash code qui est ensuite compressé en un entier appartenant au range(0,N-1) et sert de clé pour un tableau statique.
	
	Cette structure est celle qui propose la meilleure efficacité et est suffisamment versatile pour être utilisée dans la plupart des situations. Les conditions sont qu'on puisse calculer le hash des clés, et qu'on ne doive pas récupérer lesdites clés (inefficace pour compter le nombre d’occurrences d'un mot, par exemple).
	
	Complexité : toutes les fonctions principales de map pour une hash table sont de complexité moyenne O(1). Dans le pire cas (collision à chaque hash) on passe en O(n) (en supposant que les buckets sont remplis comme des unsorted list map).
	En effet, une fois le hash calculé on peut accéder directement à l'élément (pour le get) sans recherche, et la table a une taille fixe et ne doit donc pas être réorganisée lors de l'ajout ou du retrait d'un élément.
	

	\subsection*{Sorted map}
	
	Basée sur une ArrayList d'objets MapEntry<> triées en fonction de la comparaison des clés.
	
	Cette implémentation est efficace si l'on veut pouvoir aisément retrouver une clé (pour récupérer ou modifier sa valeur), mais peu efficace si les clés évoluent souvent (utilisation de \texttt{remove} ou de \texttt{put} sur une clé n'existant pas encore) car le tableau doit être réorganisé.
	
	\vspace{0.35cm}	
	
	Complexité :
	
	\texttt{get(k)} : complexité dépendant de l'algorithme de recherche. Généralement du O(log(n)) (recherche binaire).
	
	\texttt{put(k,v)} : complexité de la recherche de la position O(log(n)). Si la clé n'existe pas encore, il faut ajouter la complexité de la réorganisation de la liste O(n).
	
	\texttt{remove(k)} : recherche et réorganisation de la liste, O(n).


	\subsection*{Skip list}
	
	La description complète du principe d'une skip list est assez complexe et n'est pas l'objet de cette question. L'explication peut être trouvée dans le DSAJ6 p.402.
	
	Il s'agit d'une sorte de liste simplement chaînée contenant des liens permettant d'avancer plus rapidement que dans une liste chaînée normale (en skippant des éléments).
	Cette structure impose que la liste soit triée pour pouvoir être naviguée. Par conséquent elle ne peut pas être utilisée pour implémenter un dictionnaire non ordonné.
	
	Le fait qu'il s'agisse d'une liste chaînée et non d'une ArrayList a pour conséquence que les opérations d'ajout ou de retrait d'une nouvelle clé sont beaucoup plus efficaces. Cette implémentation est donc strictement supérieure à la sorted array list.
	
	La nature aléatoire de la skip list fait que la complexité des opérations doit être évaluée comme une complexité attendue (moyenne), et non comme la borne supérieure de la complexité exacte.
	La complexité attendue est donc O(log(n)) pour les trois opérations de base.
	
	\subsection*{Binary search tree}
	
	Il s'agit d'un arbre ordonné trié de telle sorte que chaque nœud possède une valeur, un enfant plus petit et un enfant plus grand que lui.
	
	Puisque les nœuds sont chaînés et l'arbre trié, toutes les opérations de recherche s'exécutent en O(h) où h est la hauteur de l'arbre, et les opérations de modifications en O(1). Par conséquent, les méthodes \texttt{put}, \texttt{get} et \texttt{remove} sont de complexité O(h).
	
	Cette implémentation est donc aussi efficace qu'une skip list si l'arbre est équilibré (car dans ce cas, h=log(n)). Toutefois, si l'arbre est fortement déséquilibré (par exemple les valeurs sont introduites par ordre croissant), alors h peut augmenter jusqu'à, dans le pire cas, h=n.
	

\section*{Question 3}
\section*{Question 4}
\section*{Question 5}
\section*{Question 6}
\section*{Question 7}
\section*{Question 8}
\section*{Question 9}
% add sections if more questions

\end{document}
