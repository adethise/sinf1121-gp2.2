\section*{Question 6 : Arnaud Dethise}

Soient deux files, $q_{1}$ et $q_{2}$.

push(A) : ajouter A dans la file non-vide ($q_{1}$).

pop() : transférer tous les éléments de la file non-vide ($q_{1}$) dans la file vide ($q_{2}$), à l'exception du dernier élément. Retourner le dernier élément. $q_{2}$ est maintenant la file non-vide, $q_{1}$ est la file vide.

\vspace{0.75cm}
Ainsi, les opérations suivantes :
\begin{lstlisting}
	push(1)
	push(2)
	push(3)
	a = pop()
	b = pop()
\end{lstlisting}
se traduisent en utilisant des files par :
\begin{lstlisting}
	q1.enqueue(1)                %   q1: [1]        q2: []
	q1.enqueue(2)                %   q1: [2,1]      q2: []
	q1.enqueue(3)                %   q1: [3,2,1]    q2: []
	q2.enqueue(p1.dequeue())     %   q1: [3,2]      q2: [1]
	q2.enqueue(p1.dequeue())     %   q1: [3]        q2: [2,1]
	a = q1.dequeue()             %   q1: []         q2: [2,1]
	q1.enqueue(p2.dequeue())     %   q1: [1]        q2: [2]
	b = q2.dequeue()             %   q1: [1]        q2: []
\end{lstlisting}

La complexité de la fonction push est alors de $\Theta(1)$ et celle de pop est de $\Theta(N)$ où N est le nombre d'élément dans la pile. Il est possible d'implémenter la pile au moyen de files de telle sorte que les complexités de push et pop soient inversées.

Cette solution est donc moins efficace que les implémentations normales d'une pile, dont la complexité est en temps constant pour push() et pop().

\vspace{0.75cm}
Nous avons également discuté en séance de la possibilité d'implémenter une file à partir de deux piles. La solution, pour laquelle la fonction push a une complexité constante $\Theta(1)$ et la fonction pop a une complexité moyenne $\Theta(1)$, est indiquée ci-dessous.

\begin{lstlisting}
	pile A
	pile B
	
	function enqueue(n) :
		A.push(n)
		
	function dequeue() :
		if B.isEmpty() :
			while not A.isEmpty() :
				B.push(A.pop())
		return B.pop()
\end{lstlisting}